/*----------------------------------------------------------------------
       _                  _
  ___ | |_   ___    ___  | | ___
 / __|| __| / _ \  / _ \ | |/ __|
| (__ | |_ | (_) || (_) || |\__ \
 \___| \__| \___/  \___/ |_||___/

    The source code `uf.ctools.tlpp` is based on a more detailed and feature-rich
    source code, `dna.tech.ctools.tlpp`, and implements part of the functionalities
    present in the latter.

*/

#include "totvs.ch"
#include "parmtype.ch"

namespace uf
using namespace uf

class cTools

    static method RetPictVal(nVal as numeric,lDecZero as logical,nInt as numeric,nDec as numeric,lPictSepMil as logical) as character
    static method TextRuler(cText as character,lStep10 as logical) as character

    static method StrTokArray(cString as character,cToken as character,bEvalToken as codeblock,aStrTokArr as array) as array
    static method StrTokCount(cString as character,cToken as character,bEvalToken as codeblock) as numeric
    static method StrTokCountArray(cString as character,cToken as character,bEvalToken as codeblock) as array

end class

static method RetPictVal(nVal,lDecZero,nInt,nDec,lPictSepMil) class cTools

    local cPictVal as character

    paramtype nVal as numeric
    paramtype lDecZero as logical optional
    paramtype nInt as numeric optional
    paramtype nDec as numeric optional
    paramtype lPictSepMil as logical optional

    cPictVal:=RetPictVal(@nVal,@lDecZero,@nInt,@nDec,@lPictSepMil)

    if (Right(cPictVal,2)==".9")
        cPictVal+="9"
    endif

    if (Left(cPictVal,1)==",")
        cPictVal:=SubStr(cPictVal,2)
    endif

    return(cPictVal)

static function RetPictVal(nVal as numeric,lDecZero as logical,nInt as numeric,nDec as numeric,lPictSepMil as logical) as character

    local cPict as character
    local cPictSepMil as character

    local uInt
    local uDec

    uInt:=Int(nVal)
    uDec:=(nVal-uInt)
    dfv():Default(@lDecZero,.F.)
    if ((uDec==0).and.(!(lDecZero)))
        uDec:=nil
    endif
    if (uDec<>nil)
        uDec:=allTrim(Str(uDec))
        uDec:=SubStr(uDec,At(".",uDec)+1)
        uDec:=len(uDec)
    endif
    uInt:=len(allTrim(Str(uInt)))
    nInt:=uInt
    cPict:=Replicate("9",uInt)
    dfv():Default(@lPictSepMil,.F.)
    if (lPictSepMil)
        if (nInt>3)
            cPictSepMil:=cPict
            cPict:=""
            for uInt:=nInt To 1 Step-3
                cPict:=(","+SubStr(cPictSepMil,-3,uInt)+cPict)
            next uInt
        endif
    endif
    if (uDec<>nil)
        cPict+="."
        cPict+=Replicate("9",uDec)
        nDec:=uDec
    endif

    return(cPict)

static method TextRuler(cText,lStep10) class cTools

    local cMult:="" as character
    local cRuller:="1234567890" as character
	local cTextRuler:="" as character

    local nStr as numeric
    local nStep10 as numeric

    paramtype 1 var cText as character
    paramtype 2 var lStep10 as logical optional default .T.

    nStr:=Len(cText)
    nStep10:=0

    while (Len(cTextRuler)<nStr)
        if (!lStep10)
            nStep10+=10
            if (nStep10>1000000000)
                exit
            endif
            cMult:=LTrim(Str(nStep10))
            cMult:=PadL(cMult,10)
            cTextRuler+=cMult
        else
            cTextRuler+=cRuller
        endif
    end while

    cTextRuler:=Left(cTextRuler,nStr)

return(cTextRuler)

static method StrTokArray(cString,cToken,bEvalToken,aStrTokArr) class cTools

    local lTokCount:=.F. as logical

    paramtype 1 var cString as character
    paramtype 2 var cToken as character optional default "+"
    paramtype 3 var bEvalToken as block optional
    paramtype 4 var aStrTokArr as array optional default Array(0)

    aStrTokArr:=strToKArray(@cString,@cToken,@bEvalToken,@aStrTokArr,@lTokCount)

return(aStrTokArr)

static method StrTokCount(cString,cToken,bEvalToken) class cTools

    local aStrTokArr:=Array(0) as array
    local lTokCount:=.T. as logical

    local nStrTokCount:=0 as numeric

    paramtype 1 var cString as character
    paramtype 2 var cToken as character optional default "+"
    paramtype 3 var bEvalToken as block optional

    nStrTokCount:=strToKArray(@cString,@cToken,@bEvalToken,@aStrTokArr,@lTokCount)

    FWFreeArray(@aStrTokArr)

return(nStrTokCount)

static method StrTokCountArray(cString,cToken,bEvalToken) class cTools

    local aStrTokArr as array

    local cStr as character

    local nIndex:=0 as numeric
    local nATToken as numeric
    local nRealSize as numeric
    local nStrTokCount as numeric

    paramtype 1 var cString as character
    paramtype 2 var cToken as character optional default "+"
    paramtype 3 var bEvalToken as block optional

    nStrTokCount:=cTools():StrTokCount(@cString,cToken,bEvalToken)
    aStrTokArr:=Array(nStrTokCount)

    nRealSize:=Len(cToken)
    while ((nATToken:=AT(cToken,cString))>0)
        cStr:=Left(cString,(nATToken-1))
        aStrTokArr[++nIndex]:=cStr
        cString:=subStr(cString,(nATToken+nRealSize))
    end while

    if (Len(cString)>0)
        aStrTokArr[++nIndex]:=cString
    endif

    cStr:=""
    cString:=""

return(aStrTokArr)

static function strToKArray(cString,cToken,bEvalToken,aStrTokArr,lTokCount) as variant

    local cStr,cStringNew as character

    local lAdd:=.T. as logical
    local lbEvalToken:=(valType(bEvalToken)=="B") as logical

    local nATToken as numeric
    local nRealSize as numeric
    local nStrTokCount:=0 as numeric

    nRealSize:=Len(cToken)
    while ((nATToken:=AT(cToken,cString))>0)
        cStr:=Left(cString,(nATToken-1))
        if (lbEvalToken)
            lAdd:=eval(bEvalToken,@cStr)
        endif
        if (lAdd)
            if (lTokCount)
                nStrTokCount++
            else
                aAdd(aStrTokArr,cStr)
            endif
            cStringNew+=cStr
            cStringNew+=cToken
        endif
        cString:=subStr(cString,(nATToken+nRealSize))
    end while

    if (Len(cString)>0)
        cStr:=cString
        cString:=""
        if (lbEvalToken)
            lAdd:=eval(bEvalToken,@cStr)
        endif
        if (lAdd)
            if (lTokCount)
                nStrTokCount++
            else
                aAdd(aStrTokArr,cStr)
            endif
            cStringNew+=cStr
        endif
    endif

    cStr:=""
    cString:=cStringNew
    cStringNew:=""

return(if(lTokCount,nStrTokCount,aStrTokArr))
