/*
         __     _                  _
 _   _  / _|   | |_   ___    ___  | | ___
| | | || |_    | __| / _ \  / _ \ | |/ __|
| |_| ||  _| _ | |_ | (_) || (_) || |\__ \
 \__,_||_|  (_) \__| \___/  \___/ |_||___/

*/
#include "totvs.ch"
#include "parmtype.ch"

namespace uf
using namespace uf

class UFTools
    static method RetPictVal(nVal as numeric,lDecZero as logical,nInt as numeric,nDec as numeric,lPictSepMil as logical) as character
    static method TextRuler(cText as character,lStep10 as logical) as character
    static method StrTokArray(cString as character,cToken as character,bEvalToken as codeblock) as array
end class

static method RetPictVal(nVal,lDecZero,nInt,nDec,lPictSepMil) class UFTools

    local cPictVal as character

    paramtype nVal as numeric
    paramtype lDecZero as logical optional
    paramtype nInt as numeric optional
    paramtype nDec as numeric optional
    paramtype lPictSepMil as logical optional

    cPictVal:=RetPictVal(@nVal,@lDecZero,@nInt,@nDec,@lPictSepMil)

    if (Right(cPictVal,2)==".9")
        cPictVal+="9"
    endif

    if (Left(cPictVal,1)==",")
        cPictVal:=SubStr(cPictVal,2)
    endif

    return(cPictVal)

static function RetPictVal(nVal as numeric,lDecZero as logical,nInt as numeric,nDec as numeric,lPictSepMil as logical) as character

    local cPict as character
    local cPictSepMil as character

    local uInt
    local uDec

    uInt:=Int(nVal)
    uDec:=(nVal-uInt)
    dfv():Default(@lDecZero,.F.)
    if ((uDec==0).and.(!(lDecZero)))
        uDec:=nil
    endif
    if (uDec<>nil)
        uDec:=allTrim(Str(uDec))
        uDec:=SubStr(uDec,At(".",uDec)+1)
        uDec:=len(uDec)
    endif
    uInt:=len(allTrim(Str(uInt)))
    nInt:=uInt
    cPict:=Replicate("9",uInt)
    dfv():Default(@lPictSepMil,.F.)
    if (lPictSepMil)
        if (nInt>3)
            cPictSepMil:=cPict
            cPict:=""
            for uInt:=nInt To 1 Step-3
                cPict:=(","+SubStr(cPictSepMil,-3,uInt)+cPict)
            next uInt
        endif
    endif
    if (uDec<>nil)
        cPict+="."
        cPict+=Replicate("9",uDec)
        nDec:=uDec
    endif

    return(cPict)

static method TextRuler(cText,lStep10) class UFTools

    local cMult:="" as character
    local cRuller:="1234567890" as character
	local cTextRuler:="" as character

    local nStr as numeric
    local nStep10 as numeric

    paramtype 1 var cText as character
    paramtype 2 var lStep10 as logical optional default .T.

    nStr:=Len(cText)
    nStep10:=0

    while (Len(cTextRuler)<nStr)
        if (!lStep10)
            nStep10+=10
            if (nStep10>1000000000)
                exit
            endif
            cMult:=LTrim(Str(nStep10))
            cMult:=PadL(cMult,10)
            cTextRuler+=cMult
        else
            cTextRuler+=cRuller
        endif
    end while

    cTextRuler:=Left(cTextRuler,nStr)

return(cTextRuler)

static method StrTokArray(cString,cToken,bEvalToken) class UFTools

    local aStrTokArr:=array(0) as array

    local cStr as character

    local lAdd:=.T. as logical
    local lbEvalToken as logical

    local nATToken as numeric
    local nRealSize as numeric

    paramtype 1 var cString as character
    paramtype 2 var cToken as character optional default "+"
    paramtype 3 var bEvalToken as block optional

    lbEvalToken:=(valType(lbEvalToken)=="B")

    nRealSize:=Len(cToken)
    while ((nATToken:=AT(cToken,cString))>0)
        cStr:=Left(cString,(nATToken-1))
        if (lbEvalToken)
            lAdd:=eval(bEvalToken,@cStr)
        endif
        if (lAdd)
            aAdd(aStrTokArr,cStr)
        endif
        cString:=subStr(cString,(nATToken+nRealSize))
    end while

    if (Len(cString)>0)
        cStr:=cString
        cString:=""
        if (lbEvalToken)
            lAdd:=eval(bEvalToken,@cStr)
        endif
        if (lAdd)
            aAdd(aStrTokArr,cStr)
        endif
    endif

    cStr:=""

return(aStrTokArr)
