/*
         __     _                  _
 _   _  / _|   | |_   ___    ___  | | ___
| | | || |_    | __| / _ \  / _ \ | |/ __|
| |_| ||  _| _ | |_ | (_) || (_) || |\__ \
 \__,_||_|  (_) \__| \___/  \___/ |_||___/


    The source code `uf.tools.tlpp` is based on a more detailed and feature-rich
    source code, `dna.tech.ctools.tlpp` and `dna.tech.ctools.tlpp`, and implements part of the functionalities
    present in the latter.

*/
#include "totvs.ch"
#include "parmtype.ch"

namespace uf
using namespace uf

class UFTools
    static method RetPictVal(nVal as numeric,lDecZero as logical,nInt as numeric,nDec as numeric,lPictSepMil as logical) as character
    static method TextRuler(cText as character,lStep10 as logical) as character
    static method StrTokArray(cString as character,cToken as character,bEvalToken as codeblock,aStrTokArr as array) as array
    static method GetAutoGRLog(lKeepErrors as logical,lSanitization as logical) as array
    static method SetBlindMode(lSetBlind as logical) as logical
end class

static method RetPictVal(nVal,lDecZero,nInt,nDec,lPictSepMil) class UFTools

    local cPictVal as character

    paramtype nVal as numeric
    paramtype lDecZero as logical optional
    paramtype nInt as numeric optional
    paramtype nDec as numeric optional
    paramtype lPictSepMil as logical optional

    cPictVal:=RetPictVal(@nVal,@lDecZero,@nInt,@nDec,@lPictSepMil)

    if (Right(cPictVal,2)==".9")
        cPictVal+="9"
    endif

    if (Left(cPictVal,1)==",")
        cPictVal:=SubStr(cPictVal,2)
    endif

    return(cPictVal)

static function RetPictVal(nVal as numeric,lDecZero as logical,nInt as numeric,nDec as numeric,lPictSepMil as logical) as character

    local cPict as character
    local cPictSepMil as character

    local uInt
    local uDec

    uInt:=Int(nVal)
    uDec:=(nVal-uInt)
    dfv():Default(@lDecZero,.F.)
    if ((uDec==0).and.(!(lDecZero)))
        uDec:=nil
    endif
    if (uDec<>nil)
        uDec:=allTrim(Str(uDec))
        uDec:=SubStr(uDec,At(".",uDec)+1)
        uDec:=len(uDec)
    endif
    uInt:=len(allTrim(Str(uInt)))
    nInt:=uInt
    cPict:=Replicate("9",uInt)
    dfv():Default(@lPictSepMil,.F.)
    if (lPictSepMil)
        if (nInt>3)
            cPictSepMil:=cPict
            cPict:=""
            for uInt:=nInt To 1 Step-3
                cPict:=(","+SubStr(cPictSepMil,-3,uInt)+cPict)
            next uInt
        endif
    endif
    if (uDec<>nil)
        cPict+="."
        cPict+=Replicate("9",uDec)
        nDec:=uDec
    endif

    return(cPict)

static method TextRuler(cText,lStep10) class UFTools

    local cMult:="" as character
    local cRuller:="1234567890" as character
	local cTextRuler:="" as character

    local nStr as numeric
    local nStep10 as numeric

    paramtype 1 var cText as character
    paramtype 2 var lStep10 as logical optional default .T.

    nStr:=Len(cText)
    nStep10:=0

    while (Len(cTextRuler)<nStr)
        if (!lStep10)
            nStep10+=10
            if (nStep10>1000000000)
                exit
            endif
            cMult:=LTrim(Str(nStep10))
            cMult:=PadL(cMult,10)
            cTextRuler+=cMult
        else
            cTextRuler+=cRuller
        endif
    end while

    cTextRuler:=Left(cTextRuler,nStr)

return(cTextRuler)

static method StrTokArray(cString,cToken,bEvalToken,aStrTokArr) class UFTools

    local cStr as character

    local lAdd:=.T. as logical
    local lbEvalToken as logical

    local nATToken as numeric
    local nRealSize as numeric

    paramtype 1 var cString as character
    paramtype 2 var cToken as character optional default "+"
    paramtype 3 var bEvalToken as block optional
    paramtype 4 var aStrTokArr  as array optional default Array(0)

    lbEvalToken:=(valType(lbEvalToken)=="B")

    nRealSize:=Len(cToken)
    while ((nATToken:=AT(cToken,cString))>0)
        cStr:=Left(cString,(nATToken-1))
        if (lbEvalToken)
            lAdd:=eval(bEvalToken,@cStr)
        endif
        if (lAdd)
            aAdd(aStrTokArr,cStr)
        endif
        cString:=subStr(cString,(nATToken+nRealSize))
    end while

    if (Len(cString)>0)
        cStr:=cString
        cString:=""
        if (lbEvalToken)
            lAdd:=eval(bEvalToken,@cStr)
        endif
        if (lAdd)
            aAdd(aStrTokArr,cStr)
        endif
    endif

    cStr:=""

return(aStrTokArr)

static method GetAutoGRLog(lKeepErrors,lSanitization) class UFTools
    local __aErrAuto as array
    local aErrorLog:=aClone(GetAutoGRLog()) as array
    local cError as character
    local nError,nErrors as numeric
    paramtype 1 var lKeepErrors as logical optional default .T.
    paramtype 2 var lSanitization as logical optional default .T.
    if (lKeepErrors)
        //Warning: __aErrAuto é um "Ponteiro" para __aErrAuto de VarAutoLog. Não limpar
        __aErrAuto:=VarAutoLog()
        if (!lSanitization)
            aEval(aErrorLog,{|e|aAdd(__aErrAuto,e)})
        else
            nErrors:=Len(aErrorLog)
            for nError:=1 to nErrors
                cError:=aErrorLog[nError]
                if (aScan(__aErrAuto,{|e|(e==cError)})==0)
                    aAdd(__aErrAuto,cError)
                endif
            next nError
        endif
    endif
return(aErrorLog)

static method SetBlindMode(lSetBlind) class UFTools
return(Blind():SetBlindMode(@lSetBlind))
