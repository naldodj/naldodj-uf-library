/*

         __     _      _  _             _     _                  _
 _   _  / _|   | |__  | |(_) _ __    __| |   | |_   ___    ___  | | ___
| | | || |_    | '_ \ | || || '_ \  / _` |   | __| / _ \  / _ \ | |/ __|
| |_| ||  _| _ | |_) || || || | | || (_| | _ | |_ | (_) || (_) || |\__ \
 \__,_||_|  (_)|_.__/ |_||_||_| |_| \__,_|(_) \__| \___/  \___/ |_||___/


    The source code `uf.blind.tools.tlpp` is based on a more detailed and feature-rich
    source code, `dna.tech.blind.tools.tlpp` and implements part of the functionalities
    present in the latter.

*/

namespace uf
using namespace uf

static s__aBlindMode:=Array(0) as array
static s__nBlindModeAT as numeric

#include "set.ch"
#include "totvs.ch"
#include "common.ch"
#include "parmtype.ch"

class Blind
    static method SetBlindMode(lSetBlind as logical) as logical
    static method SaveBlindMode() as variant
    static method RestoreBlindMode() as variant
end class

static method SetBlindMode(lSetBlind) class Blind

    local lIsBlind:=IsBlind() as logical

    paramtype 1 var lSetBlind as logical default lIsBlind

    if (!lSetBlind)
        HelpInDark(!lSetBlind)
        if ((Type("__cInternet")=="C").and.(__cInternet=="AUTOMATICO"))
            __cInternet:=NIL
        endif
    else
        HelpInDark(lSetBlind)
        __cInternet:="AUTOMATICO"
    endif

return(lIsBlind)

static method SaveBlindMode() class Blind

    local cStack:=ProcName(1) as character
    local cSv__cInternet as character
    local lSv__lHelpInDark as logical

    if (Type("__cInternet")=="C")
        cSv__cInternet:=__cInternet
    endif

    lSv__lHelpInDark:=HelpInDark(.T.)
    HelpInDark(lSv__lHelpInDark)

    aAdd(s__aBlindMode,JSONObject():New())
    s__nBlindModeAT:=Len(s__aBlindMode)
    s__aBlindMode[s__nBlindModeAT]["stack"]:=cStack
    s__aBlindMode[s__nBlindModeAT]["__cInternet"]:=cSv__cInternet
    s__aBlindMode[s__nBlindModeAT]["lHelpInDark"]:=lSv__lHelpInDark

return

static method RestoreBlindMode() class Blind

    local cStack:=ProcName(1) as character

    begin sequence

        if ((valType(s__aBlindMode)!="A").or.(Empty(s__aBlindMode)))
            break
        endif

        if (valType(s__nBlindMode)!="N")
            s__nBlindMode:=aScan(s__aBlindMode,{|jStack|jStack["stack"]==cStack})
            if (s__nBlindMode==0)
                break
            endif
        elseif (s__nBlindMode<=Len(s__aBlindMode))
            if (s__aBlindMode[s__nBlindMode]["stack"]!=cStack)
                s__nBlindMode:=aScan(s__aBlindMode,{|jStack|jStack["stack"]==cStack})
                if (s__nBlindMode==0)
                    break
                endif
            endif
        endif

        if (ISCHARACTER(s__aBlindMode[s__nBlindMode]["__cInternet"]))
            __cInternet:=s__aBlindMode[s__nBlindMode]["__cInternet"]
        else
            __cInternet:=NIL
        endif

        if (ISLOGICAL(s__aBlindMode[s__nBlindMode]["lHelpInDark"]))
            HelpInDark(s__aBlindMode[s__nBlindMode]["lHelpInDark"])
        endif

        FreeObj(@s__aBlindMode[s__nBlindMode])
        aDel(s__aBlindMode,s__nBlindMode)
        s__nBlindMode:=Len(s__aBlindMode)
        aSize(s__aBlindMode,--s__nBlindMode)

    end sequence

return
